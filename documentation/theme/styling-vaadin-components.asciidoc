---
title: Styling Vaadin Components
order: 6
layout: page
---

= Styling Vaadin Components

This section describes how you can write style sheets for Vaadin components and customize their internal theme implementation.

Vaadin components utilize Shadow DOM to encapsulate and scope their styles and hides the internal HTML element hierarchy.
This prevents components and the application from accidentally affecting each other’s styles or from breaking the element hierarchy. The internal style scope is sometimes referred to as “local scope”, whereas the main page scope is called the global scope.

Vaadin components internally use https://github.com/vaadin/vaadin-themable-mixin/[`ThemableMixin`] which allows developers to add custom style sheets to the component’s local scope.


=== Prerequisites

You should be familiar with <<style-scopes#,style scopes>> and how to <<including-style-sheets#component-local-scope, include style sheets into component scopes>> before you can style Vaadin components effectively.

===== Contents

* <<custom-properties>>
* <<stylable-parts>>
* <<states>>
* <<sub-components>>
* <<overlays>>
// * <<icons>>
* <<scoping-component-styles>>

=== Example

Customizing the scoped styles of Text Field.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
:host {
  padding: 0;
}

[part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-30pct);
  background-color:var(--lumo-base-color);
}

[part="input-field"]:hover {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-50pct);
}

:host([invalid]) [part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-error-color);
}
----

[NOTE]
You might need to use more specific selectors to override the current theme’s styles.
Use the browser inspector to identify the applied styles for the element that you wish to customize.

== Custom Properties

Currently, the only global CSS that can affect styles inside a shadow DOM’s local scope are properties that are inherited.
Properties can be inherited by default, like `font-family`, `color` and all custom properties, or explicitly by the custom element using the `inherit` property value.

You can adjust any component-specific custom properties in the global scope, making them affect all instances of the component.

.`Styles included into the global scope`
[source,css]
----
html {
  --vaadin-text-field-default-width: 10em;
}
----

[NOTE]
When including CSS in your client-side code (JavaScript or HTML), remember to take care of cross-browser compatibility.
See <<including-style-sheets#global-client-side, Global Scope / Client-side>> for more info.

You can find component-specific custom properties from the component's HTML API documentation.
For example, see the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section for Text Field].

Most components do _not_ have any specific custom properties.
Instead, themes provide most of the custom properties that you can customize.

== Stylable Parts

Vaadin components define certain elements inside their shadow DOM as their stylable parts.
They form the public theming and styling API of the component, together with custom properties and state attributes.
These stylable elements are marked with the `part` attribute.

The `[part]` attribute selector is the only one you should use to target elements inside a component.
Other selectors (such as `.class` or `+#id+`) may stop working with any release because they are considered as internal implementation details.

The internal parts of each component are listed in the component's HTML API documentation.
See the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section in Text Field API docs] for an example.

=== Example

.Stylable parts of <vaadin-text-field>
image:images/vaadin-text-field-parts.png[vaadin-text-field with stylable parts highlighted in the UI and in shadow DOM markup]

As an example, let's modify the Text Field component's internal "input field" to have a border and a different background color than the default Lumo theme has.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
[part="input-field"] {
  /* We use box-shadow for the border to avoid changing the dimensions of the element */
  /* We use the Lumo custom properties to make our changes automatically adapt to
     the dark palette */
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-30pct);
  background-color:var(--lumo-base-color);
}
----

=== Supported selectors

==== :host

The host element can be targeted using the `:host` selector.

[source,css]
----
:host {
  /* For example, styles for <vaadin-text-field> element */
}
----

==== [part="..."]

The stylable elements (marked with a `part` attribute) should only be targeted using the `[part="..."]` attribute selector.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
[part="input-field"] {
  /* Styles for <vaadin-text-field>'s input-field part */
}
----

==== [part~="..."]

Use `part~="..."` to match a part which might have multiple names. For example, the cells inside a `<vaadin-grid>` have multiple part names like `"cell"` and `"body-cell"`.

image:images/vaadin-grid-cell-parts.png[vaadin-grid shadow DOM where the stylable part names of header and body cells are highlighted]

You can use this kind of attribute selector in all cases, if you want to be safe.
It will work for parts with only one name as well.

.`Styles included into the local scope of <vaadin-grid>`
[source,css]
----
[part~="cell"] {
  /* Styles that affect all grid cells, including header, body and footer cells */
}

[part~="body-cell"] {
  /* Styles that only affect all body cells */
}
----

**Do not rely on the element type** which a part applies to.
For example, given `<input type="text" part="value">`, you should not rely on the information that the element is actually a native `<input>` element.
This is considered as an internal implementation detail.
The element type could change in the future while the part name stays the same, for example, to `<div contenteditable="true" part="value">`.

==== ::before and ::after

Pseudo-element selectors (`::before` and `::after`) can be used in combination with the `:host` and `[part]` selectors.
The built-in themes can also use the pseudo-elements, so be aware of potential collisions.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
[part="input-field"]::after {
  content: "";
  ...
}
----

== States

Some custom elements expose some of their internal state as top-level attributes for styling purposes.

Let's add one more detail to our custom text field styles: a different border-color when the field is invalid, using the `+[invalid]+` state attribute selector.
Learn more about <<styling-component-states#,styling component states>>.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
:host([invalid]) [part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-error-color);
}
----

The state attributes for each component are listed in the component's HTML API documentation.
See the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section in Text Field API docs] for an example.

In addition to the `[state]` attributes, standard CSS pseudo-classes (`:hover`, `:active`, etc.) can be used for both the component host and stylable parts.

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
[part="input-field"]:hover {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-50pct);
}
----

Similarly to the host element, named parts can also expose state attributes for themselves, which can be used for styling.
These are also listed in the element’s API documentation.

For example, you can target a selected date in a `<vaadin-date-picker>`:

.`Styles included into the local scope of <vaadin-month-calendar>`
[source,css]
----
[part~="date"][selected] {
 /* Styles for a selected date */
}
----

== Sub-components

Components contain other components inside their shadow DOM.
This creates a hierarchy of style scopes.

The customizations we did for the Text Field component end up affecting other components as well, which internally use Text Field.
For example, Combo Box, Date Picker, Time Picker and Select all contain a Text Field, and those components will automatically "inherit" our style customizations.

In some cases it is undesirable to style all component instances and affect sub-components across multiple parent components.
Sometimes you only want to target the Text Field inside a single Combo Box.

Theme variants (the `theme` attribute values) are propagated from the parent component to all of its sub-components.
They allow you to scope sub-component styles per-instance.

++++
<details>
<summary>
  <b>Hierarchy of stylable Vaadin components</b> (Click to expand)
</summary>
++++

The following components allow you to style their stylable parts in their local style scope.
Technically they extend `ThemableMixin`.

Nested items are sub-components, meaning the `theme` attribute is propagated to them from their parent component.
The overlay components are rendered directly under the `<body>` element and are not nested inside their parent component in the resulting DOM.

Styles are inherited when components are extended.

*Accordion*

* `<vaadin-accordion>`
** `<vaadin-accordion-panel>` (extends `<vaadin-details>`)

*App Layout*

* `<vaadin-app-layout>`
* `<vaadin-drawer-toggle>`

*Button*

* `<vaadin-button>`

*Checkbox*

* `<vaadin-checkbox>`
* `<vaadin-checkbox-group>`

*Combo Box*

* `<vaadin-combo-box>` (and `<vaadin-combo-box-light>`)
** `<vaadin-text-field>` (not in `<vaadin-combo-box-light>`)
** `<vaadin-combo-box-overlay>` (extends `<vaadin-overlay>`)
*** `<vaadin-combo-box-item>` (extends `<vaadin-item>`)

*Confirm Dialog*

* `<vaadin-confirm-dialog>`
** `<vaadin-dialog>`

*Context Menu*

* `<vaadin-context-menu>`
** `<vaadin-context-menu-overlay>` (extends `<vaadin-overlay>`)
*** `<vaadin-context-menu-list-box>` (extends `<vaadin-list-box>`)
**** `<vaadin-context-menu-item>` (extends `<vaadin-item>`)

*CRUD*

* `<vaadin-crud>`
** `<vaadin-crud-grid>` (extends `<vaadin-grid>`)
** `<vaadin-dialog-layout>`
*** `<vaadin-dialog>`

*Custom Field*

* `<vaadin-custom-field>`

*Date Picker*

* `<vaadin-date-picker>` (and `<vaadin-date-picker-light>`)
** `<vaadin-text-field>` (not in `<vaadin-date-picker-light>`)
** `<vaadin-date-picker-overlay>` (extends `<vaadin-overlay>`)
*** `<vaadin-date-picker-overlay-content>`
**** `<vaadin-month-calendar>`

*Date-Time Picker*

* `<vaadin-date-time-picker>`
** `<vaadin-custom-field>`
*** `<vaadin-date-picker>`
*** `<vaadin-time-picker>`

*Details*

* `<vaadin-details>`

*Dialog*

* `<vaadin-dialog>`
** `<vaadin-dialog-overlay>` (extends `<vaadin-overlay>`)

*Form Layout*

* `<vaadin-form-layout>`
* `<vaadin-form-item>`

*Grid*

* `<vaadin-grid>`
* `<vaadin-grid-sorter>`
* `<vaadin-grid-tree-toggle>`

*Grid Pro*

* `<vaadin-grid-pro>`
* `<vaadin-grid-pro-edit-checkbox>` (extends `<vaadin-checkbox>`)
* `<vaadin-grid-pro-edit-select>` (extends `<vaadin-select>`)
* `<vaadin-grid-pro-edit-text-field>` (extends `<vaadin-text-field>`)

*Item*

* `<vaadin-item>`

*List Box*

* `<vaadin-list-box>`

*Login*

* `<vaadin-login-overlay>`
** `<vaadin-login-overlay-wrapper>` (extends `<vaadin-overlay>`)
* `<vaadin-login-form>`
** `<vaadin-login-form-wrapper>`

*Menu Bar*

* `<vaadin-menu-bar>`
** `<vaadin-menu-bar-button>`
** `<vaadin-menu-bar-submenu>` (extends `<vaadin-context-menu>`)

*Notification*

* `<vaadin-notification>`
** `<vaadin-notification-card>`

*Ordered Layout*

* `<vaadin-horizontal-layout>`
* `<vaadin-vertical-layout>`

*Progress Bar*

* `<vaadin-progress-bar>`

*Radio Button*

* `<vaadin-radio-button>`
* `<vaadin-radio-group>`

*Rich Text Editor*

* `<vaadin-rich-text-editor>`

*Select*

* `<vaadin-select>`
** `<vaadin-select-text-field>` (extends `<vaadin-text-field>`)
** `<vaadin-select-overlay>` (extends `<vaadin-overlay>`)

*Split Layout*

* `<vaadin-split-layout>`

*Tabs*

* `<vaadin-tabs>`
** `<vaadin-tab>`

*Text Field*

* `<vaadin-email-field>` (extends `<vaadin-text-field>`)
* `<vaadin-integer-field>` (extends `<vaadin-text-field>`)
* `<vaadin-number-field>` (extends `<vaadin-text-field>`)
* `<vaadin-password-field>` (extends `<vaadin-text-field>`)
* `<vaadin-text-area>`
* `<vaadin-text-field>`

*Time Picker*

* `<vaadin-time-picker>`
** `<vaadin-time-picker-text-field>`
** `<vaadin-combo-box-overlay>` (extends `<vaadin-overlay>`)

*Upload*

* `<vaadin-upload>`
* `<vaadin-upload-file>`

---

++++
</details>
++++

.`Using the Text Field "small" theme variant on Combo Box`
```html
<vaadin-combo-box theme="small"></vaadin-combo-box>
```

image:images/vaadin-combo-box-theme-propagation.png[vaadin-combo-box theme attribute propagating to its sub-components]

Theme variant propagation is not limited to the built-in variants.
Your custom theme variants will propagate in the same way.


== Overlays

Components such as Dialog, Notification, Combo Box, Date Picker, Time Picker, Select, Menu Bar and Context Menu internally use the Overlay component (`<vaadin-overlay>`).

The Overlay component allows the main components to render content on top of all other components in the application.
It avoids any potential clipping stacking context issues where the overlay would be partially or completely hidden depending on where it is placed in the component hierarchy.
One example of a such situation are Grid rows, which create a clipping stacking context.

All components that have an overlay sub-component have their own extension of the base Overlay component, for example “Dialog Overlay” (`<vaadin-dialog-overlay>`) and “Date Picker Overlay” (`<vaadin-date-picker-overlay>`).

See <<sub-components>> for the component hierarchy reference.

[NOTE]
An overlay is considered as a sub-component of the main component and <<theme-variants#sub-component-variants, Sub-component variants>> apply to them as well.

In some cases the parent component can be completely hidden (e.g. Dialog) whereas sometimes both the parent component and its overlay component can contain content (e.g. Date Picker).

=== Stylable Parts

The `<vaadin-overlay>` component, including and all components extending it, contains the following stylable parts:

* `overlay`: The visual container of the overlay. It is typically also a scrolling container so you should avoid setting padding to it.
* `content`: The content area inside the `overlay`. You can apply padding to this part.
* `backdrop`: The optional modality curtain that covers the whole viewport and is visually behind the `overlay` part.


==== Example

Changing the background color and padding of the Dialog overlay component.

.`Styles included into the local scope of <vaadin-dialog-overlay>`
[source,css]
----
[part="overlay"] {
  background-color: var(--lumo-contrast-10pct);
}

[part="content"] {
  padding: 0;
}
----

// == Icons
//
// TODO

== Scoping Component Styles

A style sheet defined for a <<including-style-sheets#component-local-scope,component’s local scope>> affects all the instances of the component.
But what if you only want to target a single instance of a component with custom styles?

There are two ways to scope styles to specific component instances:

1. *Expose new custom properties*
  This is the recommended first option for simple situations.
  If you end up exposing more than a handful of properties, you should consider the second option.
2. *Use scoping selectors*
  This approach is used by the built-in variations in Vaadin themes (Lumo and Material), i.e. `theme` attribute.
  The downside of this approach is that you end up adding the selectors and properties to all instances, even though only some instances will need those styles (they won’t apply unless the scoping selector is used on the host element).

=== Example: Expose new custom properties

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
[part="input-field"] {
  background-color: var(--input-field-background-color, #fff);
}
----

.`Another style sheet in your app`
[source,css]
----
/* Use the new custom property */
.some-part-of-my-app vaadin-text-field {
  --input-field-background-color: #eee;
}
----

=== Example: Use scoping selectors

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
:host(.special-field) [part="input-field"] {
  background-color: #000;
  color: #fff;
  border: 2px solid #fff;
  border-radius: 9px;
}
----

[source,html]
----
<!-- Use the new scoping selector anywhere in your app -->
<vaadin-text-field class="special-field"></vaadin-text-field>
----

You can also use the `theme` attribute (i.e. <<theme-variants#custom-variants,custom component variants>>) as a scoping selector for your style overrides, as shown in the example below.
The `theme` attribute has the benefit of propagating through the <<sub-components,sub-components>> (other attributes are not).

==== Example: Scoping using the theme attribute

.`Styles included into the local scope of <vaadin-text-field>`
[source,css]
----
:host([theme~="special-field"]) [part="input-field"] {
  background-color: #000;
  color: #fff;
  border: 2px solid #fff;
  border-radius: 9px;
}
----

[source,html]
----
<!-- Apply the theme attribute to any text-field in your app -->
<vaadin-text-field theme="special-field"></vaadin-text-field>
----

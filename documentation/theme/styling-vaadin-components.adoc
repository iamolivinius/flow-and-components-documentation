---
title: Styling Vaadin Components
order: 6
layout: page
---

= Styling Vaadin Components

Vaadin components utilize Shadow DOM to encapsulate and scope their styles and hides the internal HTML element hierarchy. This prevents components and the application from accidentally affecting each other’s styles or from breaking the element hierarchy.

The internal style scope is sometimes referred to as “local scope”, whereas the main page scope is called the global scope. Learn more about <<style-scopes#,style scopes>>.

This section describes how you can write CSS for Vaadin web components and customize their internal theme implementation.

=== Prerequisites

You should be familiar with <<including-style-sheets#component-local-scope, including style sheets into component scopes>> before you can style web components effectively.

===== Contents

* <<custom-properties>>
* <<stylable-parts>>
* <<states>>
* <<sub-components>>
* <<overlays>>
* <<icons>>

=== Example

Customizing the scoped styles of a certain component, for example Text Field.

.`styles/text-field.css`
[source,css]
----
:host {
  padding: 0;
}

[part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-30pct);
  background-color:var(--lumo-base-color);
}

[part="input-field"]:hover {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-50pct);
}

:host([invalid]) [part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-error-color);
}
----

== Custom Properties

You can adjust any component-specific custom properties in the global scope, making them affect all instances of the component.

.`styles/global.css`
[source,css]
----
html {
  --vaadin-text-field-default-width: 10em;
}
----

You can find component-specific custom properties from the component's HTML API documentation. For example, see the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section for Text Field].

Most components do _not_ have any specific custom properties. Instead, themes provide most of the custom properties that you can customize.

== Stylable Parts

Vaadin components define certain elements inside their shadow DOM as their stylable parts. They form the public theming and styling API of the component, together with custom properties and state attributes. These stylable elements are marked with the `part` attribute.

The `[part]` attribute selector is the only one you should use to target elements inside a component. Other selectors (such as `.class` or `+#id+`) may stop working with any release because they are considered as internal implementation details.

The internal parts of each component are listed in the component's HTML API documentation. See the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section in Text Field API docs] for an example.

=== Example

As an example, let's modify the Text Field component's internal "input field" to have a border and a different background color than the default Lumo theme has.

.`styles/text-field.css`
[source,css]
----
[part="input-field"] {
  /* We use box-shadow for the border to avoid changing the dimensions of the element */
  /* We use the Lumo custom properties to make our changes automatically adapt to
     the dark palette */
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-30pct);
  background-color:var(--lumo-base-color);
}
----

Use the `:host` selector to target the components root element (e.g. the `<vaadin-text-field>` element).

.`styles/text-field.css`
[source,css]
----
:host {
  padding: 0;
}
----

Pseudo-element selectors (`::before` and `::after`) can be used in combination with the `:host` and `[part]` selectors. The built-in themes can also use the pseudo-elements, so be aware of potential collisions.

.`styles/text-field.css`
[source,css]
----
[part="input-field"]::after {
  content: "";
  ...
}
----

== States

Let's add one more detail to our custom text field styles: a different border-color when the field is invalid, using the `+[invalid]+` state attribute selector. Learn more about <<styling-component-states#,styling component states>>.

.`styles/text-field.css`
[source,css]
----
:host([invalid]) [part="input-field"] {
  box-shadow: inset 0 0 0 1px var(--lumo-error-color);
}
----

The state attributes for each component are listed in the component's HTML API documentation. See the https://vaadin.com/components/vaadin-text-field/html-api/elements/Vaadin.TextFieldElement[Styling section in Text Field API docs] for an example.

In addition to the `[state]` attributes, standard CSS pseudo-classes (`:hover`, `:active`, etc.) can be used for both the component host and stylable parts.

.`styles/text-field.css`
[source,css]
----
[part="input-field"]:hover {
  box-shadow: inset 0 0 0 1px var(--lumo-contrast-50pct);
}
----

== Sub-components

The customizations we did for the Text Field component end up affecting other components as well, which internally use Text Field. For example, Combo Box, Date Picker, Time Picker and Select all contain a Text Field, so those components will automatically "inherit" our style customizations.

To learn more about sub-components and how to style them, see <<using-theme-variants#sub-component-variants, Sub-component variants>> and <<styling-sub-components#,Styling sub-components>>.

== Overlays

TODO below

The `<vaadin-overlay>` component allows you to create an overlay. This component an essential part of many components, for example, `dialog`, `notification`, `combo-box`, `date-picker`, `time-picker`, `select` and `context-menu`. These components are made up of two components:

* *Main* component, for example `<vaadin-dialog>`, that is not visible (`display:none`) on the page.
* *Overlay* component, for example `<vaadin-dialog-overlay>`, that is visible on the page.

Styling overlay components (e.g. Dialogs or the popup which contains the items for Combo Box or Select, or the Date Picker calendar, etc.) is covered in <<styling-overlay-components#,Styling overlay components>>.

An overlay is considered as a sub-component of the main component and <<using-theme-variants#sub-component-variants, Sub-component variants>> apply to them as well.

TODO below

The `<vaadin-overlay>` component contains three stylable parts:

* `backdrop`: The optional modality curtain that covers the whole viewport.
* `overlay`: The container to position, size, and align the content. It is typically also a scrolling container.
* `content`: The content area inside the scrolling container (overlay). You can apply padding in this part to affect the size of the scrolled content.

The `theme` attribute is the only attribute that is copied from the main component to the overlay component. This allows you to style individual overlays. The `theme` attribute is the only exception: all other attributes (for example, the class selector) are not copied from the main component to the overlay component.

To style an overlay component, you need to create a style CSS module, target the stylable parts, instruct Vaadin to import it as a module targeting the specific component, and set the `theme` attribute to the main component in your view.

*Example*: Creating the `my-overlay-theme.css` style CSS module.

[source,css]
----
:host([theme~="custom-theme-variant"]) [part~="overlay"]
{
}
----

*Example*: Using the `@CssImport` annotation to import `my-overlay-theme.css` into `MyApplication`.

[source,java]
----
@Route(value = "")
@CssImport(value = "./styles/my-overlay-theme.css",
           themeFor = "vaadin-*-overlay")
public class MyApplication extends Div {
}
----

*Example*: Using the `setAttribute` method to set the `theme` attribute in `MyView`.

[source,java]
----
public class MyView extends VerticalLayout {
    public MyView() {
        Dialog dialog = new Dialog();
        dialog.getElement().setAttribute("theme",
                "custom-theme-variant");
    }
}
----

If you want to be more specific and target the overlay of `vaadin-dialog`, do not use wildcards in the `themeFor` attribute, rather target the `vaadin-dialog-overlay` element directly.

*Example*: Creating the `my-dialog-overlay-theme.css` style CSS module.

[source,css]
----
[part="backdrop"] {
}
[part="overlay"] {
}
[part="content"] {
}
----

*Example*: Using the `@CssImport` annotation to import `my-dialog-overlay-theme.css` into `MyApplicationWithDialog`.

.MyApplicationWithDialog.java
[source,java]
----
@Route(value = "")
@CssImport(value="./styles/my-dialog-overlay-theme.css",
           themeFor = "vaadin-dialog-overlay")
public class MyApplicationWithDialog extends Div {
}
----

== Icons

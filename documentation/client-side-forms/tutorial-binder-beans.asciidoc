---
title: Bean Validation
order: 4
layout: page
---

= Using JSR 303 Bean Validation

You can use `BeanValidationBinder` if you prefer to use JSR 303 Bean Validation annotations such as `Max`, `Min`, `Size`, etc.

`BeanValidationBinder` extends `Binder` (and therefore has the same API), but its implementation automatically adds validators based on JSR 303 constraints.

To use Bean Validation annotations, you need a JSR 303 implementation like Hibernate Validator available in your classpath. If your environment, such as Java EE container, does not provide the implementation, you can use the following dependency in Maven:

[source, xml]
----
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.4.1.Final</version>
</dependency>
----

=== Defining Constraints for Properties

*Example*: Using JSR 303 Bean Validation annotations with `BeanValidationBinder`

[source, java]
----
public class Person {
    @Max(2000)
    private int yearOfBirth;

    // Non-standard constraint provided by
    // Hibernate Validator
    @NotEmpty
    private String name;

    // + other fields, constructors, setters and getters
}

BeanValidationBinder<Person> binder =
        new BeanValidationBinder<>(Person.class);

binder.bind(nameField, "name");
binder.forField(yearOfBirthField)
    .withConverter(
        new StringToIntegerConverter("Enter a number"))
    .bind("yearOfBirth");
----

Constraints defined for properties in the bean, work in the same way as if configured programmatically when the binding is created. For example, the following code snippets have the same result:

*Example*: Declarative Bean Validation annotation.

[source, java]
----
public class Person {
    @Max(value = 2000, message =
     "Year of Birth must be less than or equal to 2000")
    private int yearOfBirth;
----
*Example*: Programmatic validation using Binder specific API.

[source, java]
----
binder.forField(yearOfBirthField)
  .withValidator(
    yearOfBirth -> yearOfBirth <= 2000,
    "Year of Birth must be less than or equal to 2000")
  .bind(Person::getYearOfBirth, Person::setYearOfBirth);
----

[NOTE]
As an alternative to defining constraint annotations for specific properties, you can define constraints on the bean level, but Vaadin's `BeanValidationBinder` does not currently support them. It simply ignores all JSR 303 validations that are not assigned directly to properties.

=== Automatically Marking Form Fields as Required

Some built-in validators in the bean validation API suggest that a value is required in input field. `BeanValidationBinder` automatically enables the visual "required" indicator using the `HasValue.setRequiredIndicatorVisible(true)` method for properties annotated with such validators. By default, `@NotNull`, `@NotEmpty` and `@Size` (if `min()` value is greater than 0) configures the field as required. You can change this behavior using the `BeanValidationBinder.setRequiredConfigurator` method.

*Example*: Overriding the default `@Size` behavior. 

[source, java]
----
binder.setRequiredConfigurator(
        RequiredFieldConfigurator.NOT_EMPTY
            .chain(RequiredFieldConfigurator.NOT_NULL));
----

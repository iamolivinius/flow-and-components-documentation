---
title: Validating and Converting User Input
order: 2
layout: page
---

= Validating and Converting User Input

`Binder` supports:

* Validating user input, and 
* Converting value types from types used in business objects to types used in bound UI components, and _vice versa_.

These concepts go hand in hand, because validation can be based on a converted value, and the ability to convert a value is a kind of validation in itself.

Vaadin includes several validators and converters that you can implement.

== Validating User Input

It is typical for applications to restrict the kind of value the user is allowed to enter into certain fields.  

=== Defining Validators

`Binder` allows you to define validators for each bound field. By default, validators run whenever the user changes the field value. The validation status is also checked when writing to the bean.

You should define the field validator between the `forField` and `bind` code lines when creating the binding.

*Example*: Defining a validator using a `Validator` instance or an inline lambda expression.

* `Binder.forField` works like a builder: the `forField` call starts the process, it is followed by various configuration calls for the field, and `bind` is the final method of the configuration.

* `asRequired` is used for mandatory fields:
** A visual "required" indicator displays. 

** If the user leaves the field  empty, an error message displays.

=== Customizing Validation Error Messages

You can customize the way error messages display by defining a `ValidationStatusHandler` or configuring the `Label` for each binding. The label is used to show the status of the field. The label can be used for validation errors, as well as confirmation and helper messages.

*Example*: Configuring validation messages for email and minimum length validation. 

* The `withStatusLabel(Label label)` method sets the given label to show an error message if the validation fails.

As an alternative to using labels, you can set a custom validation status handler, using the `withValidationStatusHandler` method. This allows you to customize how the binder displays error messages and is more flexible than using the status label approach.

=== Adding Multiple Validators

You can add multiple validators for the same binding.

*Example*: Defining two validators: first, for the email input, and second, for the expected domain.  

=== Triggering Revalidation

The validation of one field can depend on the value of another field. You can achieve this by saving the binding to a local variable and triggering revalidation when the other field fires a value-change event.

*Example*: Storing a binding for later revalidation. 


== Converting User Input

You can bind application data to a UI field component, even if the types do not match. 

Examples where this is useful include an application-specific type for a postal code that the user enters in a `TextField`, or requesting the user enter only integers in a `TextField`, or selecting enumeration values in a `Checkbox` field.

=== Defining Converters

Like validators, each binding can have one or more converters, with an optional error message.  

You can define converters using callbacks (typically lambda expressions), method references, or by implementing the `Converter` interface.

*Examples*: Defining converters. 


=== Adding Multiple Converters

You can add multiple converters (and validators) for each binding.

Each validator or converter is used in the order defined in the class. The value is passed along until:

* A final converted value is stored in the business object, or 
* The first validation error or impossible conversion is encountered.

*Example*: Validator and converter sequence.


When updating UI components, values from the business object are passed through each converter in reverse order (without validation).

[NOTE]
Although it is possible to use a converter as a validator, best practice is to use a validator to check the contents of a field, and a converter to modify the value. This improves code clarity and avoids excessive boilerplate code.

=== Conversion Error Messages

You can define a custom error message to be used if a conversion throws an unchecked exception. 

When using callbacks, you should provide one converter in each direction. If the callback used for converting the user-provided value throws an unchecked exception, the field is marked as invalid, and the exception message is used as the validation error message. Java runtime exception messages are typically written for developers, and may not be suitable for end users. 

*Example*: Defining a custom conversion error message. 


=== Implementing the Converter Interface

There are two methods to implement in the `Converter` interface:

* `convertToModel` receives a value that originates from the user.
** The method returns a `Result` that either contains a converted value or a conversion error message.
* `convertToPresentation` receives a value that originates from the business object.
** This method returns the converted value directly. It is assumed that the business object only contains valid values.

*Example*: Implementing a String to Integer Converter.

* The provided `ValueContext` can be used to find the `Locale` to be used for the conversion.
